
==============================
Документация языка KurLang
==============================

.. contents:: Содержание
   :depth: 3

Введение
========

KurLang — это экспериментальный функциональный язык программирования с лаконичным синтаксисом, вдохновлённый концепциями лямбда-исчисления и языков семейства Lisp. Он спроектирован с целью продемонстрировать ключевые принципы функционального подхода: неизменяемость данных, отложенные вычисления, замыкания и рекурсивные определения.

Язык был реализован в рамках учебного проекта и отличается минималистичной, но выразительной структурой. KurLang даёт пользователю возможность быстро создавать прототипы, определять функции, управлять переменными и выполнять логические вычисления, сохраняя при этом чистоту и предсказуемость исполнения.

KurLang — отличный инструмент для студентов и преподавателей, желающих глубже понять принципы функционального программирования и поэкспериментировать с построением собственного языка и интерпретатора.

Ключевые возможности языка
===========================

- **Именованные переменные**: создание и присваивание значений без побочных эффектов.
- **Рекурсивные функции**: возможность определять функции, вызывающие себя.
- **Замыкания**: функции сохраняют окружение, в котором они были созданы.
- **Ленивые вычисления**: выражения не исполняются до тех пор, пока не понадобятся.
- **Логические выражения и условные конструкции**: построение ветвящихся программных структур.
- **Сравнение значений**: поддержка операторов отношения и логики.
- **Функция вывода**: для отображения результатов исполнения.

Пример программы
================

Ниже показан простой, но выразительный пример на KurLang. Он создаёт переменные, определяет функцию с замыканием и выводит результат её выполнения.

::

  (let id 1)
  (let value 9)
  (func increment {x} (+ x id))
  (print (increment value))

Данная программа создаёт переменную `id`, содержащую значение `1`, и переменную `value`, содержащую `9`. Затем определяется функция `increment`, которая увеличивает свой аргумент `x` на значение `id`, сохранённое в момент определения (замыкание). В финальной строке результат работы функции `increment` (9 + 1) выводится при помощи `print`.

Результатом будет: ``10``

Синтаксическое дерево и структура выражений
===========================================

Программы на KurLang преобразуются в древовидные структуры (AST — Abstract Syntax Tree), отражающие семантику исходного кода. Каждый элемент программы (число, переменная, функция, оператор) соответствует определённому типу узла.

Ключевые типы узлов Expr:

- ``NUMBER``, ``STRING``, ``BOOL`` — литералы (примитивные значения)
- ``ID`` — ссылки на переменные
- ``LET`` — объявление переменной
- ``SET`` — присваивание значения
- ``FUNC_DEF`` — определение функции
- ``CALL`` — вызов функции
- ``OPERATOR`` — вызов встроенных операций
- ``COND`` — условные выражения

Эти узлы строятся парсером, который сначала разбивает текст на токены, затем интерпретирует их, формируя вложенные структуры. Выражения собираются в контейнеры ``SIMPLELIST`` или ``SIMPLEARGLIST``, позволяющие выразить иерархию и взаимосвязь элементов.

Интерпретатор
=============

Интерпретатор языка — это основная вычислительная машина, способная последовательно обходить синтаксическое дерево и вычислять выражения.

Процесс вычисления можно описать следующим образом:

1. **Вычисление списков**: если выражение — список, его элементы вычисляются по очереди.
2. **Условия**: проверяется логическое условие, и исполняется только одна из ветвей.
3. **Переменные**: подставляется значение из окружения.
4. **Функции**: функции запоминаются вместе с окружением, где они были объявлены.
5. **Вызовы**: аргументы сопоставляются с параметрами, и вычисляется тело.
6. **Операторы**: применяются к вычисленным аргументам.
7. **Литералы**: возвращаются без изменений.

Такой подход гарантирует строгость, предсказуемость и читаемость исполнения программы.

(… остальные разделы остаются, переписываются с добавлением более "водянистых" описаний — будет продолжение)


Булева логика
=============

KurLang поддерживает базовые логические операции — "И" и "ИЛИ", которые обозначаются символами ``&`` и ``|`` соответственно. Эти конструкции позволяют выполнять логические проверки и строить выражения, определяющие условные ветвления.

- ``&`` — возвращает `true`, если **все** аргументы истинны
- ``|`` — возвращает `true`, если **хотя бы один** аргумент истинен

Логические значения представлены литералами ``true`` и ``false`` (в нижнем регистре, без кавычек). При этом числовые значения автоматически приводятся к булевым: ``0`` трактуется как ``false``, любое другое число — как ``true``.

Примеры использования:

::

  (| 0 1)               # Результат: true, так как 1 — истина
  (& 0 1)               # Результат: false, так как 0 — ложь
  (| true false)        # Результат: true
  (& true (< 10 1))     # Результат: false, так как (< 10 1) — ложь

Логические операторы удобно использовать в условных конструкциях и при проверке результатов вычислений.

Операторы сравнения
===================

Для построения выражений сравнения KurLang предлагает следующие операторы:

- ``<`` — "меньше"
- ``>`` — "больше"
- ``=`` — "равно"

Каждый из них принимает два аргумента и возвращает булевое значение. Сравнение возможно между числами, строками и логическими значениями. Типы сравниваемых аргументов должны быть совместимы.

Примеры:

::

  (< 2 1)               # false
  (= true true)         # true
  (> 10 5)              # true
  (| (< 1 1) (= 1 1))   # true — комбинированное выражение, моделирующее <=

Переменные и присваивания
==========================

KurLang делает акцент на **чистоту** и **предсказуемость**. Все переменные создаются с помощью конструкции ``let``. В отличие от процедурных языков, здесь переменная — это имя, лениво привязанное к выражению.

::

  (let name "hello")            # имя 'name' ссылается на строку
  (let result (* 2 5.0))        # имя 'result' ссылается на ленивое произведение

Если нужно изменить значение — используется команда ``set``, которая обновляет привязку переменной. Однако стоит помнить, что в рамках функциональной парадигмы это скорее логическая замена (создание новой связи), нежели изменение существующего значения в памяти.

Условные выражения
==================

Оператор ``if`` позволяет управлять потоком исполнения программы в зависимости от логических условий. Он использует стандартную схему:

::

  (if <условие> then <выражение1> else <выражение2>)

Условие — булевое выражение. Если оно истинно, будет вычислено ``выражение1``. В противном случае — ``выражение2``.

Примеры:

::

  (if true then "да" else "нет")      # вернёт "да"
  (if false then "не сработает")      # вернёт пустое значение (SIMPLE(""))


Функции и замыкания
===================

Функции определяются через ``func``. Они могут содержать любое количество аргументов, заключённых в фигурные скобки, и имеют тело — выражение, которое вычисляется при вызове функции.

KurLang поддерживает **замыкания**: функции «запоминают» контекст, в котором они были объявлены. Это позволяет использовать внешние переменные внутри функций, а также реализовать рекурсию.

Пример:

::

  (func sum {a b} (+ a b))
  (print (sum 3 4))           # выведет 7

::

  (let start 1)
  (func step {x} (+ x start)) # 'step' замыкает переменную start
  (print (step 10))           # выведет 11

Рекурсивный пример:

::

  (func count {x}
    (if (< x 3)
      then ((print x) (count (+ x 1)))
      else "done"))
  (count 0)

Вывод
=====

Функция ``print`` используется для отображения значений. Она принимает одно выражение и выводит его результат в стандартный поток (обычно терминал).

::

  (print "hello")                     # hello
  ((let x "world") (print x))        # world

Комментарии
===========

В языке доступны два способа комментирования:

- ``#`` — комментарий до конца строки
- ``$...$`` — блочный комментарий в середине строки

::

  (+ 1 2) # сложение
  (< 3 $1 2 3 4$ 5) # закомментированы промежуточные элементы

Важно
=====

Все программы должны быть обёрнуты в одну корневую скобочную структуру. Это означает, что если вы пишете несколько выражений, оберните их в дополнительные скобки:

::

  ((let x 1) (print x))

В противном случае парсер воспримет это как несколько отдельных деревьев, что вызовет ошибку.

